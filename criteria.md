# Первый этап, быстрое отсеивание
- [ ] Переменные названы английскими существительными в единственном числе
- [ ] В названиях переменных не используются сокращения кроме общепринятых:
  - `i`, `j`, `k` для счётчиков циклов
  - `evt`, `e` для объекта события как параметра обработчика
  - `ctx` для контекста отрисовки канваса
- [ ] Функции и методы в объектах названы английскими глаголами. Как вариант, можно использовать тип данных в названии функции (`filterFn`). Исключение составляют обработчики и коллбэки
- [ ] Названия коллбэков и обработчиков формируются по следующему принципу: `on + название события` или `название события + Handler`. Можно добавлять уточняющие существительные, например, название объекта (`onButtonClick`, `buttonClickHandler`). Допустимое название для коллбэка: `cb` или `callback`
- [ ] Массивы названы английскими существительными во множественном числе или их название содержит указание на тип данных (`arr` или `list`). Название `data` для массива разрешено (множественное число от `datum`)
- [ ] Названия свойств объектов не дублируют названия объекта (`person.personName` ==> `person.name`)
- [ ] Удален ли закомментированный код?

# Правильное использование React
- [ ] Использование prop-types для определения компонентов
- [ ] Разделены ли компоненты React, чтобы уменьшить дублирование?
- [ ] Для связи React-компонент и DOM-элементов используются только `refs`, а не другие способы
- [ ] Минимизирована ли логика в методе рендеринга?
- [ ] Удален ли весь код с побочными эффектами?

# Осмысленность кода и архитектуры
- [ ] Изменены ли все var на let или const?
- [ ] Использован ли spread оператор?
- [ ] Использована ли деструктуризация?
- [ ] Название файла совпадает с названием экспортируемого через `export default` объекта (неактуально для `index.js`, в этом случае нужно смотреть на название директории)
- [ ] В коде нет необоснованной имплементации методов для работы с данными, уже встроенными в язык. Например, не нужно заново писать метод, который будет делать то же, что `Array.prototype.filter`
- [ ] Для данных подобраны подходящие структуры
  - Для списочных данных используются массивы (или соответствующие им структуры из библиотек, например, любой `List` из Immutable.js)
  - Для уникальных коллекций используется `Set`
  - Для словарей, по которым нужно итерироваться, вместо объектов и `for..in` используется `Map`
- [ ] Существуют модульные тесты для критически важных частей кодовой базы? (в первую очередь тесты для бизнес-логики, во-вторую очередь утилитные методы, в третью очередь рендеринг)
